package com.bootslee.leetcode;

/**
 * Created By BootsLee on 2020/5/3
 **/
public class Qiu12nLcof64 {
    public int sumNums(int n) {
        /**
         * 负数在参与位运算时使用的是补码
         * -1的原码是   10000000 00000000 00000000 00000001
         * -1的反码是   11111111 11111111 11111111 11111110
         * -1的补码是   11111111 11111111 11111111 11111111
         * 因此任何数与-1做与运算的结果任然为原数
         */
        /**
         * 由等差数列求和公式可知，结果等于n*(n+1)/2，其中除以2可以通过右移1位进行操作
         * 但n*(n+1)在不允许使用乘法的情况下，只能把n或n+1其中一个拆解为2的n次幂数之和，
         * 配合另一个来进行位运算和累加
         * 此代码利用了-1和任何整数进行与运算还等于原数的特点
         * -((n >> 0) & 1) 求从低到高第i+1位如果为0取 0，如果为1取-1
         * 0和任意数相与为0, -1和任意数相与为 原数
         */
        return (
                (((n + 1) & (-((n >> 13) & 1))) << 13) +
                        (((n + 1) & (-((n >> 12) & 1))) << 12) +
                        (((n + 1) & (-((n >> 11) & 1))) << 11) +
                        (((n + 1) & (-((n >> 10) & 1))) << 10) +
                        (((n + 1) & (-((n >> 9) & 1))) << 9) +
                        (((n + 1) & (-((n >> 8) & 1))) << 8) +
                        (((n + 1) & (-((n >> 7) & 1))) << 7) +
                        (((n + 1) & (-((n >> 6) & 1))) << 6) +
                        (((n + 1) & (-((n >> 5) & 1))) << 5) +
                        (((n + 1) & (-((n >> 4) & 1))) << 4) +
                        (((n + 1) & (-((n >> 3) & 1))) << 3) +
                        (((n + 1) & (-((n >> 2) & 1))) << 2) +
                        (((n + 1) & (-((n >> 1) & 1))) << 1) +
                        ((n + 1) & (-(n & 1)))
        ) >> 1;// 除以 2
    }
}
