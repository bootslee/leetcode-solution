package com.bootslee.leetcode;

public class CoinLcci8_11 {
    /**
     * 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，
     * 编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
     */

    /**
     * 题解：
     *  设 c25为一种组成情况25分的数量。依次设 c10，c5，一分硬币不用设置 只有一种情况
     *  因此我们可以得到各值的取值范围 c25=[0 , n/25] c10=[0 , (n-c25*25)/10], c5=[0, (n-c25*25-c10*10)/5]
     *  在只有 5分硬币和1分的组成情况，我们可以很简单的想到，其组成情况为 c5+1
     *  在只有10、5、1分硬币的情况下,我们可以将C10从0推导到最大，可以得知 每次得到的数量是一个等差数列（每次递减2）
     *  因为 10分是5分的两倍，每少一个10分也就多 两个 5分的组成（前面我们已经得知 5分的组成情况数量为 c5+1）
     *  根据等差数列求和公式 Sn=n*a1+n(n-1)d/2
     *  我们假设 x 为当前 c25的数量 ，得到 y=n-x*25
     *  那么项数 n = y/10 +1  首项 a1 = y % 10 / 5 + 1
     *  前面已经知道了 d=2
     *  可以得到当前组成情况 (y/10+1) * (y % 10 / 5 + 1) + (y/10+1) * (y/10 )*2/2
     *  简化后为 (y/10+1) * (y % 10 / 5 + 1 + y/10)
     * @param n
     * @return
     */
    public int waysToChange(int n) {
        int mod = 1000000007;
        int ans = 0;
        for (int i = 0; i * 25 <= n; ++i) {
            int y = n - i * 25; //减去 i 个 25硬币的剩余的数量
            int a = y / 10; //项数 - 1
            int b = y % 10 / 5; // 首项 - 1
            ans = (int)(ans + (long)(a + 1) * (a + b + 1)%mod)%mod;
        }
        return ans;
    }

    /**
     * 题解：
     * 动态规划算法
     * 我们用 f(i, v)来表示前 i 种面值的硬币构成面值为 v 的方案数量，用 c_i来表示第 i种面值的硬币的面值。
     * 我们可以从 f(i - 1, v - 0 × c_i),f(i - 1, v - 1 × c_i), f(i - 1, v - 2 × c_i) …… f(i - 1, v - k × c_i)转移得到，
     * 它们表示第 i个面值的硬币选 0, 1, 2 …… k 个的时候，构成面值为 v 的方案数量。
     * 假设这里 c={1,5,10,25}，在 i = 4的时候，c_i = 25（假设下标从 11 开始），
     * 如果我们要求前 4种面值构成 90的方案数量，可以这么写：
     *  f(4,90)=f(3,90)+f(3,90−25)+f(3,90−2×25)+f(3,90−3×25)
     * 在实现这样一个转移方程的时候，i 的取值有 4种，v的取值有 n+1 种，所以状态总数是 4(n+1)
     * 这里最多取 3 个 25，所以等式右边一共有四项，分别代表取 0、1、2、3个 25，
     * 即从前 3种面值构成 90、90−25、90−2×25、90−3×25 四个状态中进行选择。
     *
     * 优化时间复杂度
     * 把求和式展开书写：
     * f(i,v)=f(i−1,v)+f(i−1,v−ci)+f(i−1,v−2ci)⋯f(i−1,v−kci)
     * 共 k+1 项，其中 k = v/ci。那么我们可以得到使用 v−ci替换 v，得到：
     * f(i,v−ci)=f(i−1,v−ci)+f(i−1,v−2ci)+f(i−1,v−3ci)⋯f(i−1,v−kci)
     * 这样我们就可以把 把公式简化为
     *  f(i,v)=f(i−1,v)+f(i,v−ci)
     * 我们需要一个 4×(n+1) 的二维数组。
     *
     * 优化空间复杂度
     * 观察方程 f(i, v) = f(i - 1, c_i) + f(i, v - c_i)，
     * 更新二维数组的第 i行只和第 i - 1相关，
     * 用一个一维数组来实现转移：我们用数组 F[0⋯n] 表示，我们在第 i 轮计算之前i−1 轮的答案保存在 F 数组中，
     * F[v] 保存的是 i - 1 轮 f(i−1,v) 的值，在第 i 轮计算结束后，它将保存f(i,v) 的值。
     * 假设第二维从小到大更新，因为f(i,v) 只和f(i,v−ci) 和 f(i−1,v) 相关，
     * 在计算 f(i,v) 但是还没有更新 F[v] 值的时候，F[v] 保存的是上一轮的答案 f(i−1,v)，而 F[0⋯v−1] 中保存的是f(i,v′),v′∈[0,v−1] 的值，
     * f(i,v−ci) 包含在其中，所以这么做是可行的。
     */
    public int waysToChange2(int n) {
        int mod = 1000000007;
        int[] coins = {25, 10, 5, 1};
        int[] f=new int[n + 1];
        f[0] = 1;
        for (int c = 0; c < 4; ++c) {
            int coin = coins[c];
            for (int i = coin; i <= n; ++i) {
                f[i] = (f[i] + f[i - coin]) % mod;
            }
        }
        return f[n];
    }
}
